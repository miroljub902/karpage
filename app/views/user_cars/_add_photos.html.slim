- car = f.object
- max_photos = CarPolicy.new(current_user, car).max_photos
h5.text-center Upload up to #{pluralize max_photos, 'photo', 'photos'}

- if max_photos > 1
  p.text-center
    i.text-muted Drag photos to rearrange them

.photos[data-create-url=(user_car_photos_path(car) if car.persisted?)
  data-update-url=(user_car_photo_path(car, id: '_ID_') if car.persisted?)
  data-sort-url=(reorder_user_car_photos_path(car) if car.persisted?)
  data-max-photos=max_photos]
  ul.sortable
    / No AR sort because we'll have non-saved photos for new cars
    - car.photos.sort_by { |p| p.sorting || 20 }.each_with_index do |photo, n|
      li.photo.has-photo.sortable data-id=photo.id
        .img style="background-image: url(#{photo.image_url(:fill, 180, 100)})"
          .remove.sprite.sprite-delete
        span.index= n + 1
        - if photo.new_record?
          = f.fields_for :photos, [photo] do |pf|
            = pf.hidden_field :image_id
            = pf.hidden_field :image_content_type
            = pf.hidden_field :image_size
            = pf.hidden_field :image_filename
            = pf.hidden_field :sorting, class: 'sorting'

    - (1..max_photos - car.photos.size).each do |n|
      li.photo class=('single-photo' if max_photos == 1)
        .img
          .remove.sprite.sprite-delete
        span.index= n + car.photos.size

  .col-md-offset-2.col-md-8
    input.car-photos[type="file" multiple accept="image/*" data-prefix="store"
      data-s3-signer=s3_signatures_path data-s3-key=(ENV['S3_ACCESS_KEY']) data-s3-host=(ENV['S3_HOST']) data-s3-bucket=(ENV['S3_BUCKET'])]
    a.btn.btn-default.btn-block.btn-lg.car-photo-upload class=('disabled' if car.photos.size == max_photos) href="#"
      - if max_photos == 1
        'Add Photo
      - else
        = car.photos.any? ? 'Add More Photos' : 'Add Photos'
